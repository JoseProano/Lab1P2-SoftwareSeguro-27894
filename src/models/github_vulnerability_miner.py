#!/usr/bin/env python3
"""
MinerÃ­a de datos MASIVA desde GitHub
Extrae cÃ³digo vulnerable REAL de mÃºltiples fuentes
"""

import requests
import subprocess
import shutil
from pathlib import Path
from typing import List, Dict, Tuple
from loguru import logger
import time
import re
import json

class GitHubVulnerabilityMiner:
    """
    Mina repositorios con vulnerabilidades conocidas desde GitHub
    """
    
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Repositorios conocidos con vulnerabilidades documentadas
        self.vulnerable_repos = [
            # Java vulnerabilities
            {
                'url': 'https://github.com/mahmoudkanazzal/JavaSpringVulny',
                'language': 'java',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-22']
            },
            {
                'url': 'https://github.com/WebGoat/WebGoat',
                'language': 'java',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-352', 'CWE-798']
            },
            {
                'url': 'https://github.com/psiinon/bodgeit',
                'language': 'java',
                'vulnerabilities': ['CWE-89', 'CWE-79', 'CWE-22']
            },
            {
                'url': 'https://github.com/CSPF-Founder/JavaVulnerableLab',
                'language': 'java',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-611']
            },
            {
                'url': 'https://github.com/dschadow/JavaSecurity',
                'language': 'java',
                'vulnerabilities': ['CWE-89', 'CWE-502', 'CWE-798']
            },
            # Python vulnerabilities
            {
                'url': 'https://github.com/we45/Vulnerable-Flask-App',
                'language': 'python',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-611']
            },
            {
                'url': 'https://github.com/anxolerd/dvpwa',
                'language': 'python',
                'vulnerabilities': ['CWE-89', 'CWE-79', 'CWE-22']
            },
            {
                'url': 'https://github.com/sethsec/Damn-Vulnerable-GraphQL-Application',
                'language': 'python',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79']
            },
            # JavaScript/Node.js vulnerabilities
            {
                'url': 'https://github.com/OWASP/NodeGoat',
                'language': 'javascript',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-502']
            },
            {
                'url': 'https://github.com/cr0hn/vulnerable-node',
                'language': 'javascript',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-94']
            },
            {
                'url': 'https://github.com/1N3/Damn-Vulnerable-GraphQL-Application',
                'language': 'javascript',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-22']
            },
            # PHP vulnerabilities
            {
                'url': 'https://github.com/ethicalhack3r/DVWA',
                'language': 'php',
                'vulnerabilities': ['CWE-89', 'CWE-78', 'CWE-79', 'CWE-22']
            },
            {
                'url': 'https://github.com/OWASP/Vulnerable-Web-Application',
                'language': 'php',
                'vulnerabilities': ['CWE-89', 'CWE-79', 'CWE-22', 'CWE-94']
            },
        ]
    
    def clone_repository(self, repo_info: Dict) -> Path:
        """Clona repositorio"""
        repo_name = repo_info['url'].split('/')[-1].replace('.git', '')
        repo_path = self.output_dir / repo_name
        
        if repo_path.exists():
            logger.info(f"Repository {repo_name} already exists")
            return repo_path
        
        logger.info(f"Cloning {repo_info['url']}...")
        try:
            subprocess.run(
                ['git', 'clone', '--depth', '1', repo_info['url'], str(repo_path)],
                check=True,
                capture_output=True,
                text=True,
                timeout=300
            )
            logger.info(f"âœ… Cloned {repo_name}")
            return repo_path
        except Exception as e:
            logger.error(f"âŒ Failed to clone {repo_name}: {e}")
            return None
    
    def extract_code_samples(self, repo_path: Path, language: str) -> List[Dict]:
        """Extrae muestras de cÃ³digo del repositorio"""
        
        extensions = {
            'java': ['java'],
            'python': ['py'],
            'javascript': ['js'],
            'php': ['php'],
            'csharp': ['cs'],
            'c': ['c'],
            'cpp': ['cpp', 'cc'],
        }
        
        if language not in extensions:
            return []
        
        samples = []
        
        for ext in extensions[language]:
            files = list(repo_path.rglob(f'*.{ext}'))
            
            # Filtrar archivos de test/ejemplo
            files = [f for f in files if not any(x in str(f).lower() for x in ['test', 'example', 'sample', '.git'])]
            
            logger.info(f"Found {len(files)} .{ext} files in {repo_path.name}")
            
            for file_path in files:
                try:
                    code = file_path.read_text(encoding='utf-8', errors='ignore')
                    
                    # Chunks grandes (funciones/clases completas)
                    chunks = self.split_into_chunks(code, language)
                    
                    for chunk in chunks:
                        if len(chunk.strip()) > 50:  # CÃ³digo mÃ­nimo
                            samples.append({
                                'code': chunk,
                                'file': file_path.name,
                                'full_path': str(file_path),
                                'language': language,
                                'repository': repo_path.name
                            })
                
                except Exception as e:
                    logger.warning(f"Failed to read {file_path}: {e}")
        
        return samples
    
    def split_into_chunks(self, code: str, language: str) -> List[str]:
        """
        Divide cÃ³digo en chunks significativos (funciones, clases, mÃ©todos)
        """
        chunks = []
        lines = code.split('\n')
        
        if language == 'java':
            # Buscar mÃ©todos y clases completas
            in_block = False
            brace_count = 0
            current_chunk = []
            
            for line in lines:
                current_chunk.append(line)
                
                # Detectar inicio de mÃ©todo/clase
                if re.search(r'(public|private|protected|static|void|class|interface)\s+', line):
                    in_block = True
                
                # Contar llaves
                brace_count += line.count('{') - line.count('}')
                
                # Chunk completo cuando llaves balanceadas
                if in_block and brace_count == 0 and len(current_chunk) > 5:
                    chunks.append('\n'.join(current_chunk))
                    current_chunk = []
                    in_block = False
        
        elif language == 'python':
            # Buscar funciones y clases
            current_chunk = []
            in_function = False
            base_indent = 0
            
            for line in lines:
                # Detectar inicio de funciÃ³n/clase
                if re.match(r'^(def|class)\s+', line):
                    if current_chunk:
                        chunks.append('\n'.join(current_chunk))
                    current_chunk = [line]
                    in_function = True
                    base_indent = len(line) - len(line.lstrip())
                elif in_function:
                    current_indent = len(line) - len(line.lstrip())
                    if line.strip() and current_indent <= base_indent and current_chunk:
                        # Fin de funciÃ³n
                        chunks.append('\n'.join(current_chunk))
                        current_chunk = [line] if re.match(r'^(def|class)\s+', line) else []
                        base_indent = current_indent
                    else:
                        current_chunk.append(line)
                else:
                    current_chunk.append(line)
            
            if current_chunk:
                chunks.append('\n'.join(current_chunk))
        
        else:
            # Fallback: chunks por lÃ­neas
            chunk_size = 60
            for i in range(0, len(lines), chunk_size // 2):
                chunk = '\n'.join(lines[i:i+chunk_size])
                if chunk.strip():
                    chunks.append(chunk)
        
        return chunks
    
    def detect_vulnerabilities_in_code(self, code: str, language: str) -> List[str]:
        """
        Detecta patrones de vulnerabilidades en cÃ³digo REAL
        MÃ¡s sofisticado que regex simple
        """
        cwes = []
        code_lower = code.lower()
        
        # CWE-89: SQL Injection
        sql_patterns = [
            r'(select|insert|update|delete).*\+.*[\w]+',  # String concatenation
            r'executeQuery\([^)]*\+',  # Direct query execution with concat
            r'createQuery\([^)]*\+',
            r'execute\([^)]*".*select',
            r'Statement.*execute',
            r'createNativeQuery',
        ]
        
        for pattern in sql_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                if 'preparedstatement' not in code_lower:  # No usa prepared
                    cwes.append('CWE-89')
                    break
        
        # CWE-78: OS Command Injection
        cmd_patterns = [
            r'Runtime\.getRuntime\(\)\.exec',
            r'ProcessBuilder.*start',
            r'exec\([^)]*\+',
            r'system\([^)]*\+',
            r'subprocess\.(call|run|Popen)',
            r'os\.system',
        ]
        
        for pattern in cmd_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                cwes.append('CWE-78')
                break
        
        # CWE-79: XSS
        xss_patterns = [
            r'innerHTML\s*=',
            r'document\.write\(',
            r'eval\(',
            r'<script.*\+',
            r'response\.getWriter\(\)\.write.*\+',
        ]
        
        for pattern in xss_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                if 'htmlescape' not in code_lower and 'sanitize' not in code_lower:
                    cwes.append('CWE-79')
                    break
        
        # CWE-22: Path Traversal
        path_patterns = [
            r'(File|Path|FileInputStream|FileReader)\([^)]*\+',
            r'Paths\.get\([^)]*\+',
            r'open\([^)]*\+',
        ]
        
        for pattern in path_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                if 'sanitize' not in code_lower and 'validate' not in code_lower:
                    cwes.append('CWE-22')
                    break
        
        # CWE-798: Hard-coded credentials
        cred_patterns = [
            r'password\s*=\s*["\'][^"\']{6,}["\']',
            r'api[_-]?key\s*=\s*["\'][^"\']+["\']',
            r'secret\s*=\s*["\'][^"\']+["\']',
            r'token\s*=\s*["\'][^"\']{10,}["\']',
        ]
        
        for pattern in cred_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                if 'example' not in code_lower and 'test' not in code_lower:
                    cwes.append('CWE-798')
                    break
        
        # CWE-502: Insecure Deserialization
        deser_patterns = [
            r'ObjectInputStream.*readObject',
            r'pickle\.loads?',
            r'yaml\.load\(',
            r'unserialize\(',
        ]
        
        for pattern in deser_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                cwes.append('CWE-502')
                break
        
        # CWE-611: XML External Entity
        xml_patterns = [
            r'DocumentBuilderFactory',
            r'SAXParserFactory',
            r'XMLInputFactory',
        ]
        
        for pattern in xml_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                if 'setFeature' not in code:  # No desactiva XXE
                    cwes.append('CWE-611')
                    break
        
        return list(set(cwes))
    
    def generate_safe_samples(self, repo_path: Path, language: str, count: int) -> List[Dict]:
        """
        Extrae cÃ³digo SEGURO (sin vulnerabilidades detectadas)
        """
        all_samples = self.extract_code_samples(repo_path, language)
        safe_samples = []
        
        for sample in all_samples:
            cwes = self.detect_vulnerabilities_in_code(sample['code'], language)
            if not cwes:  # No vulnerabilities detected
                safe_samples.append({
                    **sample,
                    'label': 'SAFE',
                    'cwes': []
                })
                
                if len(safe_samples) >= count:
                    break
        
        return safe_samples
    
    def mine_all_repositories(self) -> Tuple[List[Dict], List[Dict]]:
        """
        Mina TODOS los repositorios y extrae muestras vulnerable/safe
        """
        all_vulnerable = []
        all_safe = []
        
        for repo_info in self.vulnerable_repos:
            logger.info(f"\n{'='*60}")
            logger.info(f"Mining: {repo_info['url']}")
            logger.info(f"Expected vulnerabilities: {repo_info['vulnerabilities']}")
            logger.info(f"{'='*60}")
            
            # Clonar
            repo_path = self.clone_repository(repo_info)
            if not repo_path or not repo_path.exists():
                continue
            
            # Extraer cÃ³digo
            samples = self.extract_code_samples(repo_path, repo_info['language'])
            logger.info(f"Extracted {len(samples)} code samples")
            
            # Clasificar vulnerable vs safe
            vulnerable_count = 0
            safe_count = 0
            
            for sample in samples:
                cwes = self.detect_vulnerabilities_in_code(sample['code'], repo_info['language'])
                
                if cwes:
                    # Es vulnerable
                    for cwe in cwes:
                        all_vulnerable.append({
                            **sample,
                            'label': cwe,
                            'cwes': cwes
                        })
                        vulnerable_count += 1
                else:
                    # Es seguro
                    all_safe.append({
                        **sample,
                        'label': 'SAFE',
                        'cwes': []
                    })
                    safe_count += 1
            
            logger.info(f"âœ… {vulnerable_count} vulnerable samples, {safe_count} safe samples")
            
            # Delay para no saturar
            time.sleep(2)
        
        logger.info(f"\n{'='*60}")
        logger.info(f"TOTAL MINING RESULTS:")
        logger.info(f"Vulnerable samples: {len(all_vulnerable)}")
        logger.info(f"Safe samples: {len(all_safe)}")
        logger.info(f"{'='*60}")
        
        return all_vulnerable, all_safe
    
    def save_samples(self, vulnerable: List[Dict], safe: List[Dict], output_file: Path):
        """Guarda muestras en JSON"""
        data = {
            'mining_date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'total_vulnerable': len(vulnerable),
            'total_safe': len(safe),
            'vulnerable_samples': vulnerable,
            'safe_samples': safe
        }
        
        output_file.write_text(json.dumps(data, indent=2))
        logger.info(f"âœ… Saved to {output_file}")


def main():
    logger.info("="*60)
    logger.info("MASSIVE VULNERABILITY DATA MINING FROM GITHUB")
    logger.info("="*60)
    
    output_dir = Path('/app/data/mined_repositories')
    miner = GitHubVulnerabilityMiner(output_dir)
    
    # Minar todos los repositorios
    vulnerable, safe = miner.mine_all_repositories()
    
    # Guardar resultados
    output_file = Path('/app/data/massive_vulnerability_dataset.json')
    miner.save_samples(vulnerable, safe, output_file)
    
    # EstadÃ­sticas
    logger.info(f"\nðŸ“Š DATASET STATISTICS:")
    logger.info(f"Total samples: {len(vulnerable) + len(safe)}")
    logger.info(f"Vulnerable: {len(vulnerable)}")
    logger.info(f"Safe: {len(safe)}")
    
    # Por CWE
    cwe_counts = {}
    for v in vulnerable:
        cwe = v['label']
        cwe_counts[cwe] = cwe_counts.get(cwe, 0) + 1
    
    logger.info(f"\nVulnerabilities by CWE:")
    for cwe, count in sorted(cwe_counts.items(), key=lambda x: x[1], reverse=True):
        logger.info(f"  {cwe}: {count}")


if __name__ == '__main__':
    main()
